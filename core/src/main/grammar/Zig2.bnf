/*
 * This file is part of ZigBrains.
 *
 * Copyright (C) 2023-2025 FalsePattern
 * All Rights Reserved
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * ZigBrains is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, only version 3 of the License.
 *
 * ZigBrains is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ZigBrains. If not, see <https://www.gnu.org/licenses/>.
 */

{
  parserClass="com.falsepattern.zigbrains.zig.parser.ZigParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  extends(".*Expr")=Expr

  psiClassPrefix="Zig"
  psiImplClassSuffix="Impl"
  psiPackage="com.falsepattern.zigbrains.zig.psi"
  psiImplPackage="com.falsepattern.zigbrains.zig.psi.impl"

  elementTypeHolderClass="com.falsepattern.zigbrains.zig.psi.ZigTypes"
  elementTypeClass="com.falsepattern.zigbrains.zig.parser.ZigElementType"

  tokenTypeClass="com.falsepattern.zigbrains.zig.parser.ZigTokenType"
  generateTokenAccessors = true
  tokens=[

      //Symbols
      AMPERSAND='&'
      AMPERSANDEQUAL='&='
      ASTERISK='*'
      ASTERISK2='**'
      ASTERISKEQUAL='*='
      ASTERISKPERCENT='*%'
      ASTERISKPERCENTEQUAL='*%='
      ASTERISKPIPE='*|'
      ASTERISKPIPEEQUAL='*|='
      CARET='^'
      CARETEQUAL='^='
      COLON=':'
      COMMA=','
      DOT='.'
      DOT2='..'
      DOT3='...'
      DOTASTERISK='.*'
      DOTQUESTIONMARK='.?'
      EQUAL='='
      EQUALEQUAL='=='
      EQUALRARROW='=>'
      EXCLAMATIONMARK='!'
      EXCLAMATIONMARKEQUAL='!='
      LARROW='<'
      LARROW2='<<'
      LARROW2EQUAL='<<='
      LARROW2PIPE='<<|'
      LARROW2PIPEEQUAL='<<|='
      LARROWEQUAL='<='
      LBRACE='{'
      LBRACKET='['
      LPAREN='('
      MINUS='-'
      MINUSEQUAL='-='
      MINUSPERCENT='-%'
      MINUSPERCENTEQUAL='-%='
      MINUSPIPE='-|'
      MINUSPIPEEQUAL='-|='
      MINUSRARROW='->'
      PERCENT='%'
      PERCENTEQUAL='%='
      PIPE='|'
      PIPE2='||'
      PIPEEQUAL='|='
      PLUS='+'
      PLUS2='++'
      PLUSEQUAL='+='
      PLUSPERCENT='+%'
      PLUSPERCENTEQUAL='+%='
      PLUSPIPE='+|'
      PLUSPIPEEQUAL='+|='
      QUESTIONMARK='?'
      RARROW='>'
      RARROW2='>>'
      RARROW2EQUAL='>>='
      RARROWEQUAL='>='
      RBRACE='}'
      RBRACKET=']'
      RPAREN=')'
      SEMICOLON=';'
      SLASH='/'
      SLASHEQUAL='/='
      TILDE='~'

      //Keywords
      KEYWORD_ADDRSPACE='addrspace'
      KEYWORD_ALIGN='align'
      KEYWORD_ALLOWZERO='allowzero'
      KEYWORD_AND='and'
      KEYWORD_ANYFRAME='anyframe'
      KEYWORD_ANYTYPE='anytype'
      KEYWORD_ASM='asm'
      KEYWORD_ASYNC='async'
      KEYWORD_AWAIT='await'
      KEYWORD_BREAK='break'
      KEYWORD_CALLCONV='callconv'
      KEYWORD_CATCH='catch'
      KEYWORD_COMPTIME='comptime'
      KEYWORD_CONST='const'
      KEYWORD_CONTINUE='continue'
      KEYWORD_DEFER='defer'
      KEYWORD_ELSE='else'
      KEYWORD_ENUM='enum'
      KEYWORD_ERRDEFER='errdefer'
      KEYWORD_ERROR='error'
      KEYWORD_EXPORT='export'
      KEYWORD_EXTERN='extern'
      KEYWORD_FN='fn'
      KEYWORD_FOR='for'
      KEYWORD_IF='if'
      KEYWORD_INLINE='inline'
      KEYWORD_NOALIAS='noalias'
      KEYWORD_NOSUSPEND='nosuspend'
      KEYWORD_NOINLINE='noinline'
      KEYWORD_OPAQUE='opaque'
      KEYWORD_OR='or'
      KEYWORD_ORELSE='orelse'
      KEYWORD_PACKED='packed'
      KEYWORD_PUB='pub'
      KEYWORD_RESUME='resume'
      KEYWORD_RETURN='return'
      KEYWORD_LINKSECTION='linksection'
      KEYWORD_STRUCT='struct'
      KEYWORD_SUSPEND='suspend'
      KEYWORD_SWITCH='switch'
      KEYWORD_TEST='test'
      KEYWORD_THREADLOCAL='threadlocal'
      KEYWORD_TRY='try'
      KEYWORD_UNION='union'
      KEYWORD_UNREACHABLE='unreachable'
      KEYWORD_USINGNAMESPACE='usingnamespace'
      KEYWORD_VAR='var'
      KEYWORD_VOLATILE='volatile'
      KEYWORD_WHILE='while'

      CONTAINER_DOC_COMMENT='container doc comment'
      DOC_COMMENT='doc comment'
      LINE_COMMENT='comment'

      CHAR_LITERAL='character literal'

      FLOAT='float'
      INTEGER='integer'

      STRING_LITERAL_SINGLE='quoted string literal'
      STRING_LITERAL_MULTI='multiline string literal'
      BAD_SQUOT='unterminated character literal'
      BAD_DQUOT='unterminated string'

      IDENTIFIER='identifier'
      BUILTINIDENTIFIER='builtin identifier'
    ]

  //Mixins
  mixin("StringLiteral")="com.falsepattern.zigbrains.zig.psi.impl.mixins.ZigStringLiteralMixinImpl"
  implements("StringLiteral")="com.falsepattern.zigbrains.zig.psi.mixins.ZigStringLiteralMixin"
}

Root ::= CONTAINER_DOC_COMMENT? ContainerMembers;

// *** Top level ***
ContainerMembers ::= ContainerDeclaration* (ContainerField COMMA)* (ContainerField | ContainerDeclaration*);

ContainerDeclaration ::= TestDecl | ComptimeDecl | DOC_COMMENT? KEYWORD_PUB Decl;

TestDecl ::= KEYWORD_TEST (STRING_LITERAL_SINGLE | IDENTIFIER)? Block;

ComptimeDecl ::= KEYWORD_COMPTIME Block;

Decl
::= (KEYWORD_EXPORT | KEYWORD_EXTERN STRING_LITERAL_SINGLE? | KEYWORD_INLINE | KEYWORD_NOINLINE)? FnProto (SEMICOLON | Block)
  | (KEYWORD_EXPORT | KEYWORD_EXTERN STRING_LITERAL_SINGLE?)? KEYWORD_THREADLOCAL? GlobalVarDecl
  ;

FnProto ::= KEYWORD_FN IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr;

VarDeclProto ::= (KEYWORD_CONST | KEYWORD_VAR) IDENTIFIER (COLON TypeExpr)? ByteAlign? AddrSpace? LinkSection?;

GlobalVarDecl ::= VarDeclProto (EQUAL Expr)? SEMICOLON;

ContainerField ::= DOC_COMMENT? KEYWORD_COMPTIME? !KEYWORD_FN (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL Expr)?;

// *** Block Level ***
Statement
::= KEYWORD_COMPTIME ComptimeStatement
  | KEYWORD_NOSUSPEND BlockExprStatement
  | KEYWORD_SUSPEND BlockExprStatement
  | KEYWORD_DEFER BlockExprStatement
  | KEYWORD_ERRDEFER Payload? BlockExprStatement
  | IfStatement
  | LabeledStatement
  | VarDeclExprStatement
  ;

ComptimeStatement
::= BlockExpr
  | VarDeclExprStatement
  ;

IfStatement
::= IfPrefix BlockExpr (KEYWORD_ELSE Payload? Statement)?
  | IfPrefix AssignExpr (SEMICOLON | KEYWORD_ELSE Payload? Statement)
  ;

LabeledStatement ::= BlockLabel? (Block | LoopStatement | SwitchExpr);


LoopStatement ::= KEYWORD_INLINE? (ForStatement | WhileStatement);

ForStatement
::= ForPrefix BlockExpr (KEYWORD_ELSE Statement)?
  | ForPrefix AssignExpr (SEMICOLON | KEYWORD_ELSE Statement)
  ;


WhileStatement
::= WhilePrefix BlockExpr (KEYWORD_ELSE Payload? Statement)?
  | WhilePrefix AssignExpr (SEMICOLON | KEYWORD_ELSE Payload? Statement)
  ;

BlockExprStatement
::= BlockExpr
  | AssignExpr SEMICOLON
  ;


BlockExpr ::= BlockLabel? Block;

// An expression, assignment, or any destructure, as a statement.
VarDeclExprStatement
::= VarDeclProto (COMMA (VarDeclProto | Expr))* EQUAL Expr SEMICOLON
  | Expr (AssignOp Expr | (COMMA (VarDeclProto | Expr))+ EQUAL Expr)? SEMICOLON
  ;

// *** Expression Level ***

// An assignment or a destructure whose LHS are all lvalue expressions.
AssignExpr ::= Expr (AssignOp Expr | (COMMA Expr)+ EQUAL Expr)?;

SingleAssignExpr ::= Expr (AssignOp Expr)?;

Expr ::= BoolOrExpr;

BoolOrExpr ::= BoolAndExpr (KEYWORD_OR BoolAndExpr)*;

BoolAndExpr ::= CompareExpr (KEYWORD_AND CompareExpr)*;

CompareExpr ::= BitwiseExpr (CompareOp BitwiseExpr)?;

BitwiseExpr ::= BitShiftExpr (BitwiseOp BitShiftExpr)*;

BitShiftExpr ::= AdditionExpr (BitShiftOp AdditionExpr)*;

AdditionExpr ::= MultiplyExpr (AdditionOp MultiplyExpr)*;

MultiplyExpr ::= PrefixExpr (MultiplyOp PrefixExpr)*;

PrefixExpr ::= PrefixOp* PrimaryExpr;

PrimaryExpr
::= AsmExpr
  | IfExpr
  | KEYWORD_BREAK BreakLabel? Expr?
  | KEYWORD_COMPTIME Expr
  | KEYWORD_NOSUSPEND Expr
  | KEYWORD_CONTINUE BreakLabel? Expr?
  | KEYWORD_RESUME Expr
  | KEYWORD_RETURN Expr?
  | BlockLabel? LoopExpr
  | Block
  | CurlySuffixExpr
  ;

IfExpr ::= IfPrefix Expr (KEYWORD_ELSE Payload? Expr)?

Block ::= LBRACE Statement* RBRACE;



LoopExpr ::= KEYWORD_INLINE? (ForExpr | WhileExpr);

ForExpr ::= ForPrefix Expr (KEYWORD_ELSE Expr)?;

WhileExpr ::= WhilePrefix Expr (KEYWORD_ELSE Payload? Expr)?;

CurlySuffixExpr ::= TypeExpr InitList?;

InitList
::= LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE
  | LBRACE Expr (COMMA Expr)* COMMA? RBRACE
  | LBRACE RBRACE
  ;




TypeExpr ::= PrefixTypeOp* ErrorUnionExpr;

ErrorUnionExpr ::= SuffixExpr (EXCLAMATIONMARK TypeExpr)?;

SuffixExpr ::= PrimaryTypeExpr (SuffixOp | FnCallArguments)*;

PrimaryTypeExpr
::= BUILTINIDENTIFIER FnCallArguments
  | CHAR_LITERAL
  | ContainerDecl
  | DOT IDENTIFIER
  | DOT InitList
  | ErrorSetDecl
  | FLOAT
  | FnProto
  | GroupedExpr
  | LabeledTypeExpr
  | IDENTIFIER
  | IfTypeExpr
  | INTEGER
  | KEYWORD_COMPTIME TypeExpr
  | KEYWORD_ERROR DOT IDENTIFIER
  | KEYWORD_ANYFRAME
  | KEYWORD_UNREACHABLE
  | StringLiteral
  ;

ContainerDecl ::= (KEYWORD_EXTERN | KEYWORD_PACKED)? ContainerDeclAuto;

ErrorSetDecl ::= KEYWORD_ERROR LBRACE IdentifierList RBRACE;

GroupedExpr ::= LPAREN Expr RPAREN;

IfTypeExpr ::= IfPrefix TypeExpr (KEYWORD_ELSE Payload? TypeExpr)?;

LabeledTypeExpr
::= BlockLabel Block
  | BlockLabel? LoopTypeExpr
  | BlockLabel? SwitchExpr
  ;

LoopTypeExpr ::= KEYWORD_INLINE? (ForTypeExpr | WhileTypeExpr);

ForTypeExpr ::= ForPrefix TypeExpr (KEYWORD_ELSE TypeExpr)?;

WhileTypeExpr ::= WhilePrefix TypeExpr (KEYWORD_ELSE Payload? TypeExpr)?;

SwitchExpr ::= KEYWORD_SWITCH LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE;

// *** Assembly ***
AsmExpr ::= KEYWORD_ASM KEYWORD_VOLATILE? LPAREN Expr AsmOutput? RPAREN;

AsmOutput ::= COLON AsmOutputList AsmInput?;

AsmOutputItem ::= LBRACKET IDENTIFIER RBRACKET StringLiteral LPAREN (MINUSRARROW TypeExpr | IDENTIFIER) RPAREN;

AsmInput ::= COLON AsmInputList AsmClobbers?;

AsmInputItem ::= LBRACKET IDENTIFIER RBRACKET StringLiteral LPAREN Expr RPAREN;

AsmClobbers ::= COLON Expr;

// *** Helper grammar ***
BreakLabel ::= COLON IDENTIFIER;

BlockLabel ::= IDENTIFIER COLON;

FieldInit ::= DOT IDENTIFIER EQUAL Expr;

WhileContinueExpr ::= COLON LPAREN AssignExpr RPAREN;

LinkSection ::= KEYWORD_LINKSECTION LPAREN Expr RPAREN;

AddrSpace ::= KEYWORD_ADDRSPACE LPAREN Expr RPAREN;

// Fn specific
CallConv ::= KEYWORD_CALLCONV LPAREN Expr RPAREN;

ParamDecl
::= DOC_COMMENT? (KEYWORD_NOALIAS | KEYWORD_COMPTIME)? (IDENTIFIER COLON)? ParamType
  | DOT3
  ;

ParamType
::= KEYWORD_ANYTYPE
  | TypeExpr
  ;

// Control flow prefixes
IfPrefix ::= KEYWORD_IF LPAREN Expr RPAREN PtrPayload?;

WhilePrefix ::= KEYWORD_WHILE LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?;

ForPrefix ::= KEYWORD_FOR LPAREN ForArgumentsList RPAREN PtrListPayload;

// Payloads
Payload ::= PIPE IDENTIFIER PIPE;

PtrPayload ::= PIPE ASTERISK? IDENTIFIER PIPE;

PtrIndexPayload ::= PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE;

PtrListPayload ::= PIPE ASTERISK? IDENTIFIER (COMMA ASTERISK? IDENTIFIER)* COMMA? PIPE;

// Switch specific
SwitchProng ::= KEYWORD_INLINE? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr;

SwitchCase
::= SwitchItem (COMMA SwitchItem)* COMMA?
  | KEYWORD_ELSE
  ;

SwitchItem ::= Expr (DOT3 Expr)?;

// For specific
ForArgumentsList ::= ForItem (COMMA ForItem)* COMMA?;

ForItem ::= Expr (DOT2 Expr?)?;

// Operators
AssignOp
::= ASTERISKEQUAL
  | ASTERISKPIPEEQUAL
  | SLASHEQUAL
  | PERCENTEQUAL
  | PLUSEQUAL
  | PLUSPIPEEQUAL
  | MINUSEQUAL
  | MINUSPIPEEQUAL
  | LARROW2EQUAL
  | LARROW2PIPEEQUAL
  | RARROW2EQUAL
  | AMPERSANDEQUAL
  | CARETEQUAL
  | PIPEEQUAL
  | ASTERISKPERCENTEQUAL
  | PLUSPERCENTEQUAL
  | MINUSPERCENTEQUAL
  | EQUAL
  ;

CompareOp
::= EQUALEQUAL
  | EXCLAMATIONMARKEQUAL
  | LARROW
  | RARROW
  | LARROWEQUAL
  | RARROWEQUAL
  ;

BitwiseOp
::= AMPERSAND
  | CARET
  | PIPE
  | KEYWORD_ORELSE
  | KEYWORD_CATCH Payload?
  ;

BitShiftOp
::= LARROW2
  | RARROW2
  | LARROW2PIPE
  ;

AdditionOp
::= PLUS
  | MINUS
  | PLUS2
  | PLUSPERCENT
  | MINUSPERCENT
  | PLUSPIPE
  | MINUSPIPE
  ;

MultiplyOp
::= PIPE2
  | ASTERISK
  | SLASH
  | PERCENT
  | ASTERISK2
  | ASTERISKPERCENT
  | ASTERISKPIPE
  ;

PrefixOp
::= EXCLAMATIONMARK
  | MINUS
  | TILDE
  | MINUSPERCENT
  | AMPERSAND
  | KEYWORD_TRY
  ;

PrefixTypeOp
::= QUESTIONMARK
  | KEYWORD_ANYFRAME MINUSRARROW
  | SliceTypeStart (ByteAlign | AddrSpace | KEYWORD_CONST | KEYWORD_VOLATILE | KEYWORD_ALLOWZERO)*
  | PtrTypeStart (AddrSpace | KEYWORD_ALIGN LPAREN Expr (COLON Expr COLON Expr)? RPAREN | KEYWORD_CONST | KEYWORD_VOLATILE | KEYWORD_ALLOWZERO)*
  | ArrayTypeStart
  ;

SuffixOp
::= LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET
  | DOT IDENTIFIER
  | DOTASTERISK
  | DOTQUESTIONMARK
  ;

FnCallArguments ::= LPAREN ExprList RPAREN;

// Ptr specific
SliceTypeStart ::= LBRACKET (COLON Expr)? RBRACKET;

PtrTypeStart
::= ASTERISK
  | ASTERISK2
  | LBRACKET ASTERISK ("c" | COLON Expr)? RBRACKET
  ;

ArrayTypeStart ::= LBRACKET Expr (COLON Expr)? RBRACKET;

// ContainerDecl specific
ContainerDeclAuto ::= ContainerDeclType LBRACE CONTAINER_DOC_COMMENT? ContainerMembers RBRACE;

ContainerDeclType
::= KEYWORD_STRUCT (LPAREN Expr RPAREN)?
  | KEYWORD_OPAQUE
  | KEYWORD_ENUM (LPAREN Expr RPAREN)?
  | KEYWORD_UNION (LPAREN (KEYWORD_ENUM (LPAREN Expr RPAREN)? | Expr) RPAREN)?
  ;

// Alignment
ByteAlign ::= KEYWORD_ALIGN LPAREN Expr RPAREN;

// Lists
IdentifierList ::= (DOC_COMMENT? IDENTIFIER COMMA)* (DOC_COMMENT? IDENTIFIER)?;

SwitchProngList ::= (SwitchProng COMMA)* SwitchProng?;

AsmOutputList ::= (AsmOutputItem COMMA)* AsmOutputItem?;

AsmInputList ::= (AsmInputItem COMMA)* AsmInputItem?;

ParamDeclList ::= (ParamDecl COMMA)* ParamDecl?;

ExprList ::= (Expr COMMA)* Expr?;

StringLiteral
::= STRING_LITERAL_SINGLE
  | STRING_LITERAL_MULTI+
  ;